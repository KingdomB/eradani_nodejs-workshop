# **POWERUp2019 Node.js Workshop**

## Express.js

### Intro to Node Webservers

Now that we've covered the basics of JavaScript and Node.js, we're going to apply those technologies to a common use-case: building a webserver. Webservers built with JavaScript are single-threaded and typically _stateless_, meaning they handle individual messages from clients one-at-a-time, respond, and then completely forget the client ever existed. A typical conversation (API call) between a client and a JavaScript webserver goes like this:

* Client sends an HTTP message to the Server
* Server receives the message and passes it through a series of sequential functions called _middlewares_
* Middlewares process the message in order, until finally a response is generated and sent to the client
* Client receives HTTP response and closes the connection
* Server forgets the client ever existed (does not store client information)

Building a basic webserver with Node.js so simple, you can actually do it in just _one line of code_! To make things clearer, we're going to do it in 6 lines, but give the one-line server a try if you want!

### Hello, Internet!

Open up your Repl.it editor and enter the code below into the `index.js` file. We'll dissect the code in a moment.

```javascript
const http = require('http'); // import Node's built-in http library

// Create our "application"
const app = function(request, response) {
    // Send back the string "Hello Internet!" to clients whenever they talk to our server
    response.end('Hello Internet!'); 
};

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

Once you've copied the code, hit `run`. After a few seconds, your server should now be listening for messages.

To test your server, copy the URL at the top of the **Console** section of the editor and open it up in a new tab in your web browser. If all goes well, you should see "Hello Internet!" displayed on a blank page.


**If you need help:** call a member of our staff over - we're going to build up this server, so it's important that you have it working here before we move on.


Now that we have our basic server running, let's go through each line of the program:

* `const http = require('http');` - As you may recognize from our JavaScript section, this line creates a variable called `http` and assigns it to the output of running `require('http')`. `require` is a built-in Node.js function for importing modules from other files, and the `'http'` module is a built-in Node.js module. Importing it here allows us to access its functions from our `http` variable.
* `const app = function(request, response) { ... };` - This line creates a function which takes two parameters: `request` and `response` and stores the function in the variable `app`. When our Node server receives a message, it will automatically generate a `Request` object using the data from the message it received, and a `Response` object for us to use to send data back. It will run our function and pass the `Request` object as the first parameter to the function and the `Response` object as the second parameter. The names of the parameters do not affect the server - we use the names `request` and `response` to help us remember which is which.
* `response.end('Hello Internet!');` - Our Node server will run the function we give it whenever it receives a message, but what do we want the server to send back to the client that contacted it? The `Response` object includes several properties and functions that we can use for this. One of those is the function `response.end()`, which can be used to immediately send a message back to the client and close the connection. Our line of code here tells Node to add `'Hello Internet!'` to our response message, send it to the client, and close the connection. That's why when your visit your server in your web browser, your web browser immediately receives and displays 'Hello Internet!' on the page.
* `const server = http.createServer(app);` - Node doesn't just _know_ that we want it to use our `app` function when it receives requests. We have to tell it to do that. This line of code tells the `http` module to create a webserver _which uses our `app` function_, and store it in the `server` variable.
* `server.listen();` - This line starts the server and tells it to begin listening for and responding to messages.



**Note:** the one-line webserver from before looks like this: `require('http').createServer((request, response) => response.end("Hello Internet!")).listen();`. This is a fully functional Node.js webserver in just one line of code.

### Creating an Express App

Our current webserver works well, but what if we want it to do different things or show different data based on the URL the client asked for? **We call the different URLs clients can access "_routes_"** With our current system, we _could_ create routes by checking `request.url` in our `app` function with something like this:

```javascript
const http = require('http'); // import Node's built-in http library

// Create our "application"
const app = function(request, response) {
    if (request.url === '/hello') {
        // Send back the string "Hello Internet!" to clients whenever they go to http://<our_server_address>/hello
        response.end('Hello Internet!'); 
    } else if (request.url === '/goodbye') {
        // Send back the string "Goodbye Internet!" to clients whenever they go to http://<our_server_address>/goodbye
        response.end('Goodbye Internet!');
    }
    //...more else ifs for every URL
};

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

However, real web applications may have hundreds of routes, so if we decide to develop our application this way, our `app` function is going to get very long and very complicated, very quickly. So let's use a **framework** to simplify things.

The majority of Node.js web applications today are written using the **Express.js** framework, so we'll use that.

**First, we'll need to install Express**. On repl.it, click the cube icon on the far left side of your screen (the one that says "packages"). In the package search bar, type "Express" and click the first option in the search results. A plus inside a circle should appear. Click it to add Express to your application. Once Express has been added, repl will open up your `package.json` file, which is used by Node for managing your application's dependencies. You should see Express listed under "dependencies".

Now go back to editing your main server file, `index.js`. You can get there by clicking the page icon on the far left side of your screen (the one that says "Files"), and selecting "index.js".

Just like any other dependency in Node, in order to use Express, we'll have to import it. Add this line to the top of your index.js file: `const express = require('express');`. Now that we have imported Express, we need to tell Express to initialize a new blank application which we will then add routes to. We can do this by replacing our `app` function with: `const app = express();`. Your `index.js` file should now look like this:

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

This server will run, but if you try to visit the server in your web browser, you should now see **"Cannot GET /"**. This is because we haven't defined any routes yet, and Express defaults to returning that message when you try to visit an invalid route. So let's add some routes!

One of the major advantages to using a framework like Express is that it makes it very easy to define new routes without affecting the functionality of existing routes. This makes Express applications easy to maintain and extend. The basic syntax for defining a new route looks like this: `app.get(&lt;url&gt;, &lt;routeHandlerFunction&gt;);`. Let's tell the server to say "Hello Internet" again when users go to the '/' route.

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

// Route definitions
app.get('/', function(request, response) {
    response.end('Hello Internet!');
});

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

If you visit your application server in your browser now, you should see "Hello Internet!" again!

### Accepting User Input

Now we have a functioning web application built with Express! That's cool, but our server would be a lot better if it responded appropriately based on data you send it. Let's add another route to our application which acccepts a `name` parameter and greets that person.

When sending additional parameter data along with an HTTP GET request, we place the data at the end of the URL after a question mark. For example, if we want to go to a `/hello` route and send a `name` parameter with the value `'Common'`, our URL would look like this: `http://<our_server_address>/hello?name=Common`. And one of the many reasons we use Express is that when requests come to our server with additional parameters like that, Express will automatically read them and provide them to us in an easily useable format. Once processed by Express, the parameters will be accesible in the `request.query` object. In our above example, `request.query.name` would be equal to `'Common'`. Let's implement this!

First, we create our new `'/hello'` route:

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

// Route definitions
app.get('/', function(request, response) {
    response.end('Hello Internet!');
});
// Our new '/hello' route
app.get('/hello', function(request, response) {

});

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

Now, in the handler for our `'/hello'` route, we'll access the `request.query.name` value, append it to our greeting message, and send it back to the client:

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

// Route definitions
app.get('/', function(request, response) {
    response.end('Hello Internet!');
});
// Our new '/hello' route
app.get('/hello', function(request, response) {
    response.end('Hello, ' + request.query.name);
});

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

Now try it! Visit your server again in your browser at `http://<your_server_address>/hello?name=Common` and you should see `'Hello, Common'` displayed on your screen!

### It's All Just Messages

Now that you've created a webserver that has multiple routes and accepts user input, you can build any application you can think of! It's just a matter of defining new routes and filling in the functions that tell them what to do.

This is how the entire Internet works - it's all just various server systems sending messages to one another and deciding what to do with them. **And that's by far the most powerful part of this whole thing.** Just about every server system across the Internet operates by sending and receiving HTTP messages. They don't care who sends the message or what type of technology the sender used, as long as it's a valid HTTP message, it can be handled properly.

In the next sections, we'll show you how to use Node to teach your existing IBM i applications how to speak HTTP. _As we said, as long as your system sends and receives valid HTTP messages, no other system will care what platform your code runs on or what language it is written in._ That means you are free to build your systems with whatever technologies you want and still have shiny, modern RESTful interfaces to them.