# POWERUp2019 Node.js Workshop

## Express.js

* ~~Intro to Node Webservers~~
* ~~EXTREMELY basic node server on repl.it~~
* ~~Redo with Express & one defined route~~
* HTTP overview (verbs, query, params, body...)
* Install packages and add them to Express: Morgan, BodyParser, CORS
* Add a POST route so they actually use BodyParser and see its benefits
* Install SQLite and add our SQLite module & connect to their POST route
* Add CRUD routes for one database table using the SQLite module

### Intro to Node Webservers

Now that we've covered the basics of JavaScript and Node.js, we're going to apply those technologies to a common use-case: building a webserver. Webservers built with JavaScript are single-threaded and typically _stateless_, meaning they handle individual messages from clients one-at-a-time, respond, and then completely forget the client ever existed. A typical conversation (API call) between a client and a JavaScript webserver goes like this:

* Client sends an HTTP message to the Server
* Server receives the message and passes it through a series of sequential functions called _middlewares_
* Middlewares process the message in order, until finally a response is generated and sent to the client
* Client receives HTTP response and closes the connection
* Server forgets the client ever existed (does not store client information)

Building a basic webserver with Node.js so simple, you can actually do it in just _one line of code_! To make things clearer, we're going to do it in 6 lines, but give the one-line server a try if you want!

### Hello, Internet!

Open up your editor and enter the code below into the `index.js` file. We'll dissect the code in a moment.

```javascript
const http = require('http'); // import Node's built-in http library

// Create our "application"
const app = function(request, response) {
    // Send back the string "Hello Internet!" to clients whenever they talk to our server
    response.end('Hello Internet!'); 
};

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

Once you've copied the code, hit `run`. After a few seconds, your server should now be listening for messages.

To test your server, copy the URL at the top of the **Console** section of the editor and open it up in a new tab in your web browser. If all goes well, you should see "Hello Internet!" displayed on a blank page.


**If you need help:** call a member of our staff over - we're going to build up this server, so it's important that you have it working here before we move on.


Now that we have our basic server running, let's go through each line of the program:

* `const http = require('http');` - As you may recognize from our JavaScript section, this line creates a variable called `http` and assigns it to the output of running `require('http')`. `require` is a built-in Node.js function for importing modules from other files, and the `'http'` module is a built-in Node.js module. Importing it here allows us to access its functions from our `http` variable.
* `const app = function(request, response) { ... };` - This line creates a function which takes two parameters: `request` and `response` and stores the function in the variable `app`. When our Node server receives a message, it will automatically generate a `Request` object using the data from the message it received, and a `Response` object for us to use to send data back. It will run our function and pass the `Request` object as the first parameter to the function and the `Response` object as the second parameter. The names of the parameters do not affect the server - we use the names `request` and `response` to help us remember which is which.
* `response.end('Hello Internet!');` - Our Node server will run the function we give it whenever it receives a message, but what do we want the server to send back to the client that contacted it? The `Response` object includes several properties and functions that we can use for this. One of those is the function `response.end()`, which can be used to immediately send a message back to the client and close the connection. Our line of code here tells Node to add `'Hello Internet!'` to our response message, send it to the client, and close the connection. That's why when your visit your server in your web browser, your web browser immediately receives and displays 'Hello Internet!' on the page.
* `const server = http.createServer(app);` - Node doesn't just _know_ that we want it to use our `app` function when it receives requests. We have to tell it to do that. This line of code tells the `http` module to create a webserver _which uses our `app` function_, and store it in the `server` variable.
* `server.listen();` - This line starts the server and tells it to begin listening for and responding to messages.



**Note:** the one-line webserver from before looks like this: `require('http').createServer((request, response) => response.end("Hello Internet!")).listen();`. This is a fully functional Node.js webserver in just one line of code.

### Creating an Express App

Our current webserver works well, but what if we want it to do different things or show different data based on the URL the client asked for? **We call the different URLs clients can access "_routes_"** With our current system, we _could_ create routes by checking `request.url` in our `app` function with something like this:

```javascript
const http = require('http'); // import Node's built-in http library

// Create our "application"
const app = function(request, response) {
    if (request.url === '/hello') {
        // Send back the string "Hello Internet!" to clients whenever they go to http://<our_server_address>/hello
        response.end('Hello Internet!'); 
    } else if (request.url === '/goodbye') {
        // Send back the string "Hello Internet!" to clients whenever they go to http://<our_server_address>/goodbye
        response.end('Goodbye Internet!');
    }
    //...more else ifs for every URL
};

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

However, real web applications may have hundreds of routes, so if we decide to develop our application this way, our `app` function is going to get very long and very complicated, very quickly. So let's use a **framework** to simplify things.

The majority of Node.js web applications today are written using **Express.js**, so we'll use that.

**First, we'll need to install Express**. If you're on repl.it, click the cube icon on the far left side of your screen (the one that says "packages"). In the package search bar, type "Express" and click the first option in the search results. A plus inside a circle should appear. Click it to add Express to your application. Once Express has been added, repl will open up your `package.json` file, which is used by Node for managing your application's dependencies. You should see Express listed under "dependencies".

Now go back to editing your main server file, `index.js`. You can get there by clicking the page icon on the far left side of your screen (the one that says "Files"), and selecting "index.js".

Just like any other dependency in Node, in order to use Express, we'll have to import it. Add this line to the top of your index.js file: `const express = require('express');`. Now that we have imported Express, we need to tell Express to initialize a new blank application which we will then add routes to. We can do this by replacing our `app` function with: `const app = express();`. Your `index.js` file should now look like this:

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

This server will run, but if you try to visit the server in your web browser, you should now see **"Cannot GET /"**. This is because we haven't defined any routes yet, and Express defaults to returning that message when you try to visit an invalid route. So let's add some routes!

One of the major advantages to using a framework like Express is that it makes it very easy to define new routes without affecting the functionality of existing routes. This makes Express applications easy to maintain and extend. The basic syntax for defining a new route looks like this: `app.get(&lt;url&gt;, &lt;routeHandlerFunction&gt;);`. Let's tell the server to say "Hello Internet" again when users go to the '/' route.

```javascript
const http = require('http'); // import Node's built-in http library
const express = require('express'); // import Express

// Create our application
const app = express();

// Route definitions
app.get('/', function(request, response) {
    response.end('Hello Internet!');
});

const server = http.createServer(app); // Create a basic web server using our application

server.listen(); // Tell the server to start listening for messages
```

If you visit your application server in your browser now, you should see "Hello Internet!" again!