# POWERUp2019 Node.js Workshop

## **Node.js**

![node.js logo](nodejs.png "node.js logo")

---

### **What is Node.js?**

At its core, Node.js (sometimes just called _Node_) is a JavaScript runtime that executes your JavaScript code using Google's Chrome V8 engine. In the past, JavaScript was primarily run in the browser (many of which run with Chrome V8 engine as well).

The power of Node.js is that it allows you to use JavaScript (an incredibly flexible and easy-to-learn language) to do more than just manipulate HTML and CSS in the browser. Instead, the Node.js runtime environment runs code in an environmnet similar to Java or Python: Directly on your machine with access to the kernel, file system, etc. through environment APIs. It can read and manipulate databases and files, send and receive HTTP messgages over the internet, or call C and C++ programs, just to name a few uses.

You can do nearly everything with Node.js that you are accustomed to doing in C, C++, or RPG. In fact, IBM has developed Node.js packages that allow you to call all of the RPG programs, SQL procedures, CL and QSH commands, and much more that you have invested a lot of time and money in, **allowing Node.js to build on the work that you have already done**. We will talk more about how IBM's packages allow interaction between the Node.js runtime and OS400 more below.

The Node.js runtime is supported by an extremely rich ecosystem of open-source packages which you can use in your applications for free. The **_nearly one million free packages_** include, but are _certainly_ not limited to `http` and `express` to help you easily interact with the internet, `os` to help you interact with your operating system, and `itoolkit` and `xmlservice` to help you easily interact with native programs on the IBM i.

What does this mean for you as a developer? It means that you have a rich library of packages to use in your programs, allowing you to reuse code that has already been written for things like calling or serving HTTP endpoints. This frees you to focus almost exclusively on your own application logic, greatly increasing development time compared to other technologies.

There are important things to know about the Node.js runetime in order to be a successful developer, such as the fact that it is single-threaded (sounds scarier than it is), or how the event loop works, or even advanced commands for npm. These topics would take too long to cover in this lab, and so have been included at the end of this file as an appendix, but if you are serious about Node.js, come back after to read this section.

### [Appendix: Important things to Know](#appendix)

---

### **npm: The Node Package Manager**

![npm logo](npm.png "npm logo")

One of the most compelling reasons to use Node.js is npm, The Node Package Manager. npm is a repository of over 960,000 open-source Node.js packages have been developed by members of the community, and can be found at [https://www.npmjs.com/](https://www.npmjs.com/). This makes npm the largest code repository in the entire world! To browse the packages available, simply visit the website and search in the bar for either the package name or by keywords.

The packages on range in size and scope from single-line functions that do very spcific data testing or manipulation, to entire frameworks for creating web servers and creating API endpoints. Many packages are updated very frequently and have tens of millions of downloads every week. As an example, the most popular package on npm, `lodash`, is a utility library that has 21 million weekly downloads.

Because these packages are open-source, you can go to any package, click on the link to its code repository, and see all of the code that is used to build the package. This allows you 

The best part of npm is that a lot of the boring, hard-to-implement functionality of software has already been done for you, allowing you to focus instead on writing the application logic for your business or project.

---

### **IBM i Node.js Packages**

As mentioned above, one of the main benefits of using Node.js is the robust package ecosystem that is available on NPM that allows you to do things out of the box without reinventing the wheel. As part of this ecosystem, The IBM i Open-Source Software Team has developed a number of packages that allow you to interact with your IBM i, either from a Node.js process running directly on your IBM i or a remote process running on a server or your development machine.

* **`itoolkit`**: A package that uses the IBM i XMLSERVICE to enable calls into your IBM i. Some of the things could can do with itoolkit includes calling programs, CL or QSH commands, running SQL, and many more things you are accustomed to doing in 5250. To download, run `npm install itoolkit`. More information about the package can be found at: [https://www.npmjs.com/package/itoolkit](https://www.npmjs.com/package/itoolkit)

* **`idb-connector`**: A database connector that creates a simple API for communicating with Db2 on the IBM i. **idb-connector can only be run on a Node.js instance on the IBM i, not a Node.js instance calling to a remote IBM i.** To download, run `npm install idb-connector`. More information about the package can be found at: [https://www.npmjs.com/package/idb-connector](https://www.npmjs.com/package/idb-connector).

* **`idb-pconnector`**: A wrapper for `idb-pconnector` that converts the API to use native JavaScript `Promises` instead of callback functions, and also comes with connection pooling. **Like `idb-connector`, it can only be run on IBM i**. To download, run `npm install idb-pconnector`. More information about the package can be found at [https://www.npmjs.com/package/idb-pconnector](https://www.npmjs.com/package/idb-pconnector).

* **`odbc`**: Our latest database connector, ODBC is platform (and database management system) agnostic and allows you to connect to your IBM i from any system granted that you have an ODBC driver. It also can be used directly on the IBM i. To download, run `npm install odbc@beta`. Unlike the other packages listed here, this package is not IBM i-specific, and the IBM i Open-Source Software team only recently assumed leadership over the project. However, this package will be the future of database connection on the IBM i, and so it might be best to set up your ODBC environment sooner rather than later. More information about the package can be found at: [https://www.npmjs.com/package/odbc](https://www.npmjs.com/package/odbc).

---

### **The `npm` utility**

When you download Node.js, in addition to the `node` command you also get the `npm` command. The `npm` utility helps install packages from [https://www.npmjs.com/](https://www.npmjs.com/) and manage the metadata for your program (e.g. version number, author name, scripts for running and testing, etc.).

When you create a Node.js project, usually the first thing you do is go to your project's directory and running `npm init`. This command will create a file called `package.json` that will store all of the metadata for your application. Although you don't _have_ to run `npm init` or even have a `package.json` to use Node.js, you will have to use it if you want to either

1. Publish your code on `npm`, either publically or on your private organization/enterprise repository.
2. Download any packages from npm using the `npm install` command.

So if `npm init` creates `package.json`, what does `package.json` do and why do you need it?

`package.json` is the most important file for tracking the metadata of your program. It contains a number of fields that describe your program, like the the author, version number, declares how to run the program and the test scripts, and, most importantly, keeps track of the dependencies for you program. Lets take a look at a sample `package.json`.

In a directory called `sample-app`, running `npm init -y` will setup a `package.json` using the defaults for the fields.

```
$ npm init -y
```

The file this command produces looks like the following:

`package.json`
```json
{
  "name": "sample-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

`package.json` describes your Node.js application, but currently isn't _too_ interesting. To see the real power of this file, let's add some dependencies for our application. Let's say we need a framework for creating APIs (`loopback`), a connector for our API framework (`loopback-connector-ibmi`), and a utility package to help with common programming functions (`lodash`). To be able to download these to use in our program, we are going to use `npm install`:

```
$ npm install loopback
$ npm install loopback-connector-ibmi
$ npm install lodash
```

When you install these packages, notice that you don't just get that package, **_but all of that package's dependencies as well_**. Loopback itself installs 240 packages! You can find these installed packages in the `node_modules` directory of your application (which `npm install` will create for you), and that is one of the directories that Node.js will look in when you try to include outside packages in your program. Now if we look at the contents of `package.json`, we see that the packages we installed have been added as dependencies:

`package.json`
```json
{
  "name": "sample-app",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.11",
    "loopback": "^3.25.1",
    "loopback-connector-ibmi": "^0.2.0"
  }
}

```

The real power of `package.json` comes when we look at the size of `node_modules`: 57 MB! If we wanted to keep track of the changes to our Node.js in a source control system like `git`, we would have to track this 57MB of files as well, as they are an important part of our program. Luckily, `package.json` makes it so we don't have to track all those files: It gives npm a roadmap to reinstall all the programs we need!

If we delete our `node_modules` folder, our program will no longer work. But a Node.js application without `node_modules` will simulate how the application would look when we pulled it down from our source control system.

```
$ rm -rf node_modules
```

Now, to reinstall all those files, we can call `npm install` with no package name, which will look at the list of dependencies in `package.json`, and reinstall all of our the packages our program depends on!

```
$ npm install
```

Our `node_modules` is now recreated just as it was before we deleted it! If this all seems too abstract at this moment, just know that `package.json` is an important file for keeping track of how to recreate your Node.js application.

---

### **Your First (Real) Node.js Application**

Although our previous examples were run using Node.js, we never really used anything unique to Node.js. Let's create our first application that actually uses the power of `npm` to download a package, then require that package in our code.

First, lets create a new directory called `first-app`. Navigate into this folder and run

```
$ npm init -y
```

This will create our `package.json` file, as outlined in the [npm utility](#the-npm-utility) section above. Next, we are going to install one package, `request`, which will allow us to send HTTP and HTTPS requests to servers. We won't do anything to exciting with it, but it will show you how to import packages. Install `request` like so:

```
$ npm install request
```

Next, we are going to create a JavaScript file, where were import the functionality of `request` and use it to do something interesting. Create a file called `index.js` and include the following code:

`index.js`
```JavaScript
const request = require('request');

request('https://jsonplaceholder.typicode.com/todos/1', (error, response, body) => {
  if (error) {
    throw Error(error);
  }
  console.log(`Status Code is ${response.statusCode}`);
  console.log(body);
});
```

In the first line of our program, we use the `require` module (a native part of Node.js) to require the object (in this case a function) exposed by the `request`, and assign it to the variable `request`. There are a number of places where `require` will look to resolve the name given to it, but for now we should only be concerned that it looks in our local `node_modules` folder where `request` was placed when we installed it.

We then use the function to call a free API endpoint, which returns some dummy JSON.

Note that the request function takes two parameters: A string which is the online resource we want to get, and a function (which itself has 3 parameters). This function is what is known as a **_callback function_** and is an important part of programming in Node.js.

When you do some sort of I/O work or other long-running task, packages should, in their implementation, create an asynchronous worker thread that does the operation without blocking the Node.js process from continuing. When the worker thread has completed its work, it will usually call the callback function, letting us know that the work has finished. Furthermore, it will return the results of its work in the parameters of the function.

In our case, `request` will spin up an asynchronous worker thread to go out and get the data that we requested, freeing the Node.js process to do other things while we wait. When the data is returned, the asynchronous worker thread calls the callback function, passing in data to the parameters, giving us access to the results in the body of the function.

Typically, and also in our case, the first parameter is an `Error` object if there was a problem in the execution of the function, or `null` if there was no error.

The second parameter is an object containing information about the response. It is a complex object, but for now we just print the HTTP response code (and hope that it is `200`, indicating success).

Finally, the third parameter returns the body of what the request returns. In the case of the API endpoint we requested, it is a simple JSON string, containing 4 keys.

To know what the callback will return, or even how to call packages, it is always important to read the documentation. A lot of headaches can be adverted if you put in a little time to read before you use!

We can run our program by running the following command:

```
$ node index.js
```

If all went smoothly, our output should look like:

```
Status Code is 200
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}

```

And with that, you've run your first Node.js program using someone else's code you got from NPM! Just try to imagine how much more code you would have had to write to do the same work that the `request` package enabled. You would have spent much more time writing an HTTP request function than focusing on your application logic. As mentioned above, there are hundreds-of-thousands of NPM packages for you to use that will allow you to use reusable functionality written by someone else so you can focus on your own code!

If you are confused about callback functions, don't worry, that is totally normal. As we continue to work through this lab, and as you continue to program with Node.js after this lab, they will become more familiar and you will be comfortable with them.

---

## **Conclusion**

Node.js may seem confusing at first, but it is really quite simple technology. Node.js itself is nothing more than a runtime that allows you to write programs in JavaScript, a weakly-typed and interpreted language, while also exposing access to things like the file system and http methods.

The real power of Node.js comes from the hundreds of thousands of open-source packages hosted on npmjs.com that allow you to use someone else's hard work to implement functionality in your program. This allows you to focus primarily on your business logic and not on reinventing the wheel.

IBM has invested money and development resources not just in making sure that Node.js is an enterprise-level tool, but also so that it has a robust suite of packages to interact with the IBM i. In the next few tutorials, we will create applications that use Db2 on the IBM i as a data store, showing you how to combine the technology you are already comfortable with and the power of Node.js to quickly add value to your business.

### [Next: Express.js](./5.express.js.md)

---
---

## Appendix

### Important Things to Know

// TODO: